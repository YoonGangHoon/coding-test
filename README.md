# Do it! 알고리즘 코딩 테스트 - 자바편
## 1. 준비
### 1.1. 시간 복잡도
- 일반적으로 1억번의 연산이 1초
- $O(n)$을 기준으로 생각

## 2. 디버깅
### 2.1. 디버깅을 잘 활용하자.
- 디버깅을 못해서 떨어지는 경우도 다반사
### 2.2. 흔히 하는 실수들
1. 변수 초기화 오류
2. 반복문에서 인덱스 지정 오류
3. 잘못된 변수 사용 오류
4. 자료형 범위 오류
    - 이걸 방지하려면 애초에 int가 아니라 long을 활용하자.

## 3. 자료구조
- 문제 유형에 따라 적절한 자료구조를 잘 선택하는 것이 중요하다.
### 3.1. 배열과 리스트
- 배열
  - 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조
  - 인덱스를 통해 참조 가능
  - 배열 크기는 선언할 때 지정 나중에 못 바꿈
- 리스트
  - 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조
  - 동적인 데이터를 다룰 때 유용함
  
### 3.2. 구간합
- 배열 A가 있을 때, A[i] ~ A[j] 의 합을 구하려면 어떻게 해야할까.
- 단순히 반복문을 돌 수도 있겠지만, 수가 많아지면 너무 오래걸린다.
- 이를 해결하기 위해 합 배열 S를 새로 만들건데, S[i] = A[0] + A[1] + A[2] + ... + A[i]이다.
- 좀 더 단순히 나타내면 S[i] = S[i-1] + A[i]
- $(A+B)\mod\ m = (A\mod m + B \mod m)\mod m$

### 3.3. 투 포인터
- 두 개의 포인터를 사용해 시간 복잡도를 최적화
- 연속된 구간에 대한 경우의 수를 구할 때 사용

### 3.4. 슬라이딩 윈도우
- 투 포인터랑 유사
- 투 포인터가 딱 2개의 위치만을 가지고 무언가 한다면 이건 두 점을 잡고 범위를 통째로 옮기는 느낌
- 마치 딥러닝에서 커널 움직이는 것과 같음

### 3.5. 스택과 큐
- 스택
  - LIFO: Last In First Out
  - 용어
    - top: 삽입과 삭제가 일어나는 위치
    - push: 새로운 데이터 삽입
    - pop: 데이터를 삭제하고 확인
    - peek: top에 있는 데이터를 단순 확인
  - 자바에서는?
    - ```Stack<> stack = new Stack<>();```
- 큐
  - FIFO: First In First Out
  - 용어
    - front: 가장 앞의 데이터를 가리키는 영역
    - rear: 가장 끝 데이터를 가리키는 영역
    - add: rear 부분에 새로운 데이터 삽입
    - poll: front 부분 데이터 삭제 후 확인
    - peek: front에 있는 데이터 단순 확인
  - 자바에서는?
    - ```Queue<> queue = new LinkedList<>()```

## 4. 정렬
총 6가지 정렬을 다룬다.
1. 버블 정렬
2. 선택 정렬
3. 삽입 정렬
4. 퀵 정렬
5. 병합 정렬
6. 기수 정렬

### 4.1. 버블 정렬
> 양 옆을 계속 비교하면서 너가 앞에 할래 내가 앞에 할래?
- 데이터의 인접 요소끼리 비교하고 swap 연산을 수행하며 정렬하는 방식
- 쉽다는 장점이 있지만, $O(n^2)$ 으로 느린 편
- 정렬 과정
  1. 비교 연산이 필요한 루프 범위 설정
  2. 인접한 데이터 값 비교
  3. swap 조건(```A[i] > A[j] 또는 A[i] < A[j]```)에 부합하면 swap
  4. 루프가 끝날 때까지 2~3 반복
  5. 정렬 영역을 설정하여 다음 루프를 실행할 때는 이 영역 제외
  6. 비교 대상이 없을 때까지 1~5 반복

### 4.2. 선택 정렬
> 한 칸씩 뒤로 가면서(index++) 이 자리에 뭐 넣을래?
- 대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식
- 난이도도 어렵고, $O(n^2)$ 으로 느리기 때문에 코테에서는 잘 쓰이지 않음
- 정렬 과정
  1. 남은 정렬 부분에서 최솟값 또는 최댓값 찾기
  2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap
  3. 가장 앞에 있는 데이터의 위치를 변경해(index++) 남은 정렬 부분의 범위를 축소
  4. 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없어질 때까지 반복

### 4.3. 삽입 정렬
> 알맞은 자리 찾으면 나머지 다 뒤로 밀어서 자리 만들어 주기
- 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬하는 방식
- 평균적으로 $O(n^2)$으로 느린 편이지만, 구현하기 쉬움
- 정렬 과정
  1. 현재 index에 있는 데이터 값 선택
  2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치 탐색
  3. 삽입 위치부터 index에 있는 위치까지 shift 연산 수행
  4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산 수행
  5. 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복

### 4.4. 퀵 정렬
> 기준 세워 줄테니까 양 옆으로 알아서 줄 서라
- pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식
- $O(nlogn)$으로 빠른 편, 그래도 난이도는 있는 편
- 정렬 과정
  1. 데이터를 분할하는 pivot을 설정한다.
  2. pivot을 기준으로 다음 과정을 거쳐 데이터를 2개의 집합으로 분리
     1. ```A[start]```가 ```A[pivot]```보다 작으면 start를 오른쪽으로 1칸 이동
     2. ```A[end]```가 ```A[pivot]```보다 크면 end를 왼쪽으로 1칸 이동
     3. ```A[start]```가 ```A[pivot]``` 보다 크고, ```A[end]```가 ```A[pivot]``` 보다 작으면, ```swap(A[start], A[end])``` 하고 start는 오른쪽, end는 왼쪽으로 1칸씩 이동
     4. start와 end가 만날 때까지 1.1. ~ 1.3. 을 반복
     5. start와 end가 만났을 때, 그 데이터가 A[pivot]보다 크면 오른쪽, 작으면 왼쪽에 삽입
  3. 분리 집합에서 다시 pivot 선정
  4. 분리 집합이 1개 이하가 될 때까지 1~3 반복

### 4.5. 병합 정렬
> 그룹 나눠서 줄 서고 모여서 다시 줄 서라
- 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식
- 분할 정복 방식(divide and conquer)을 사용하며, 평균적으로 $O(nlogn)$
- 정렬 수행 방식
  1. n개의 그룹으로 나눔
  2. 2개씩 그룹을 합치며 정렬
     1. 투포인터 개념을 사용하여 두 개 중 작은 수를 배열에 추가
     2. i++ or j++
  3. 최종적으로 전체가 정렬

### 4.6. 기수 정렬
> 자리 수끼리 비교해서 정렬해라
- 데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식
- $O(kn)$으로 가장 빠름
- 하지만 정수나 고정 길이 문자열처럼 자릿수가 명확한 데이터에서만 사용할 수 있음
- 정렬 수행 방식
  1. 일의 자리 수를 기준으로 정렬
  2. 십의 자리 수를 기준으로 정렬
  3. $10^{k-1}$의 자리 수를 기준으로 정렬
  4. 최종적으로 전체가 정렬됨