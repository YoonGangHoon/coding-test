# Do it! 알고리즘 코딩 테스트 - 자바편
## 1. 준비
### 1.1. 시간 복잡도
- 일반적으로 1억번의 연산이 1초
- $O(n)$을 기준으로 생각

## 2. 디버깅
### 2.1. 디버깅을 잘 활용하자.
- 디버깅을 못해서 떨어지는 경우도 다반사
### 2.2. 흔히 하는 실수들
1. 변수 초기화 오류
2. 반복문에서 인덱스 지정 오류
3. 잘못된 변수 사용 오류
4. 자료형 범위 오류
    - 이걸 방지하려면 애초에 int가 아니라 long을 활용하자.

## 3. 자료구조
- 문제 유형에 따라 적절한 자료구조를 잘 선택하는 것이 중요하다.
### 3.1. 배열과 리스트
- 배열
  - 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조
  - 인덱스를 통해 참조 가능
  - 배열 크기는 선언할 때 지정 나중에 못 바꿈
- 리스트
  - 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조
  - 동적인 데이터를 다룰 때 유용함
  
### 3.2. 구간합
- 배열 A가 있을 때, A[i] ~ A[j] 의 합을 구하려면 어떻게 해야할까.
- 단순히 반복문을 돌 수도 있겠지만, 수가 많아지면 너무 오래걸린다.
- 이를 해결하기 위해 합 배열 S를 새로 만들건데, S[i] = A[0] + A[1] + A[2] + ... + A[i]이다.
- 좀 더 단순히 나타내면 S[i] = S[i-1] + A[i]
- $(A+B)\mod\ m = (A\mod m + B \mod m)\mod m$

### 3.3. 투 포인터
- 두 개의 포인터를 사용해 시간 복잡도를 최적화
- 연속된 구간에 대한 경우의 수를 구할 때 사용

### 3.4. 슬라이딩 윈도우
- 투 포인터랑 유사
- 투 포인터가 딱 2개의 위치만을 가지고 무언가 한다면 이건 두 점을 잡고 범위를 통째로 옮기는 느낌
- 마치 딥러닝에서 커널 움직이는 것과 같음

### 3.5. 스택과 큐
- 스택
  - LIFO: Last In First Out
  - 용어
    - top: 삽입과 삭제가 일어나는 위치
    - push: 새로운 데이터 삽입
    - pop: 데이터를 삭제하고 확인
    - peek: top에 있는 데이터를 단순 확인
  - 자바에서는?
    - ```Stack<> stack = new Stack<>();```
- 큐
  - FIFO: First In First Out
  - 용어
    - front: 가장 앞의 데이터를 가리키는 영역
    - rear: 가장 끝 데이터를 가리키는 영역
    - add: rear 부분에 새로운 데이터 삽입
    - poll: front 부분 데이터 삭제 후 확인
    - peek: front에 있는 데이터 단순 확인
  - 자바에서는?
    - ```Queue<> queue = new LinkedList<>()```

## 4. 정렬
총 6가지 정렬을 다룬다.
1. 버블 정렬
2. 선택 정렬
3. 삽입 정렬
4. 퀵 정렬
5. 병합 정렬
6. 기수 정렬

### 4.1. 버블 정렬
- 데이터의 인접 요소끼리 비교하고 swap 연산을 수행하며 정렬하는 방식
- 쉽다는 장점이 있지만, $O(n^2)$ 으로 느린 편

### 4.2. 선택 정렬
- 대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식
- 난이도도 어렵고, $O(n^2)$ 으로 느리기 때문에 코테에서는 잘 쓰이지 않음